# 소담(SODAM) 프로젝트 종합 분석 보고서

## 📋 문서 개요

- **작성일**: 2024-12-27
- **작성자**: 개발팀
- **문서 유형**: 코드베이스 종합 분석 보고서
- **프로젝트명**: 소담(SODAM) - 아르바이트 근태 및 급여 관리 애플리케이션
- **분석 버전**: v2.0 (서식 정리 및 내용 보강)

## 🎯 프로젝트 개요

### 1.1 서비스 소개

소담(SODAM)은 아르바이트 근태 기록, 급여 산출, 세무 신고 연계 등의 기능을 통해 근로자와 사업자에게 효율적이고 간편한 서비스를 제공하는 크로스 플랫폼 애플리케이션입니다.

### 1.2 기술 스택 현황

| 분야         | 기술               | 버전     | 비고        |
|------------|------------------|--------|-----------|
| **백엔드**    | Java Spring Boot | 3.4.x  | 메인 서버     |
| **프론트엔드**  | React Native     | 0.80.0 | 크로스 플랫폼   |
| **웹 지원**   | React Native Web | -      | 웹 브라우저 호환 |
| **언어**     | TypeScript       | -      | 프론트엔드     |
| **언어**     | Java             | 17 LTS | 백엔드       |
| **데이터베이스** | MySQL            | 8.x    | 메인 DB     |
| **ORM**    | MyBatis          | -      | 데이터 매핑    |
| **캐시**     | Redis            | 7.x    | 세션/캐시     |
| **서버**     | AWS              | -      | 클라우드 인프라  |

### 1.3 주요 기능 현황

- ✅ **인증 시스템**: 카카오 OAuth, JWT 기반 인증
- ✅ **근태 관리**: NFC 태그 인식, 위치 기반 출퇴근
- ✅ **매장 관리**: 매장 정보, 직원 관리
- ✅ **임금 관리**: 시급 설정, 급여 계산
- ✅ **정보 서비스**: 소상공인 꿀팁, 국가정책 정보
- ✅ **Q&A 시스템**: 세무/노무 상담

## 🔍 분석 범위 및 방법론

### 2.1 분석 대상

```
📁 소스코드 분석 범위
├── 🔧 핵심 설정 파일 (application.yml, Config 클래스)
├── 🔐 Security 및 JWT 관련 코드
├── 💾 Redis 및 Cache 설정
├── 🎯 AOP 구현체
├── 🔗 컴포넌트 및 Bean 설정
├── 🌐 Controller 및 API 엔드포인트
├── ⚠️ 예외 처리 및 에러 핸들링
├── 🧪 테스트 코드 구조
├── 📱 React Native 관련 설정 (신규 추가)
├── 🗄️ 데이터베이스 최적화 (신규 추가)
└── 📊 성능 모니터링 (신규 추가)
```

### 2.2 분석 방법론

- **정적 코드 분석**: 코드베이스 2회 정독
- **보안 취약점 분석**: OWASP 기준 보안 검토
- **성능 분석**: 병목 지점 및 최적화 포인트 식별
- **아키텍처 분석**: 설계 패턴 및 구조적 문제점 검토

---

## 🚨 중요 보안 이슈

### 🔴 1. JWT Secret Key 보안 문제 ⚠️ **CRITICAL**

**📁 영향 파일**: `application.yml`, `JwtProperties.java`

**🔍 문제점**:

- JWT secret key가 소스코드에 하드코딩되어 있음
- `application.yml`과 `JwtProperties.java`에 중복 정의
- 운영환경에서 토큰 위조 가능성 존재
- 보안 키 노출로 인한 전체 인증 시스템 무력화 위험

**✅ 수정 계획**:

```yaml
# application.yml - 환경변수 활용
jwt:
  secret: ${JWT_SECRET:#{null}}
  expiration: ${JWT_EXPIRATION:3600000}
  refresh-expiration: ${JWT_REFRESH_EXPIRATION:604800000}
```

```java
// JwtProperties.java - 상수만 유지
public interface JwtProperties {
    String TOKEN_PREFIX = "Bearer ";
    String HEADER_STRING = "Authorization";
    String REFRESH_HEADER = "Refresh-Token";
    // SECRET 상수 완전 제거
}
```

**🛡️ 추가 보안 강화 방안**:

```bash
# 환경변수 설정 예시
export JWT_SECRET="your-256-bit-secret-key-here"
export JWT_EXPIRATION=3600000
export JWT_REFRESH_EXPIRATION=604800000
```

### 🔴 2. 데이터베이스 비밀번호 노출 ⚠️ **CRITICAL**

**📁 영향 파일**: `application.yml`

**🔍 문제점**:

- MySQL 비밀번호가 평문으로 설정 파일에 저장
- 소스코드 저장소에 민감한 정보 노출
- 개발/운영 환경 구분 없이 동일한 설정 사용

**✅ 수정 계획**:

```yaml
# application.yml - 환경별 설정 분리
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/sodam}
    username: ${DB_USERNAME:sodam}
    password: ${DB_PASSWORD:#{null}}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: ${DB_MIN_IDLE:5}
      connection-timeout: ${DB_CONNECTION_TIMEOUT:30000}
```

**🔒 환경별 보안 설정**:

```yaml
# application-prod.yml (운영환경)
spring:
  datasource:
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10

# application-dev.yml (개발환경)  
spring:
  datasource:
    password: ${DB_PASSWORD:devpassword}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
```

### 🟡 3. Redis 보안 설정 미흡 ⚠️ **HIGH**

**📁 영향 파일**: `RedisConfig.java`, `application.yml`

**🔍 문제점**:

- Redis 비밀번호 설정 누락
- 캐시 데이터 암호화 미적용
- Redis 연결 풀 설정 최적화 필요

**✅ 수정 계획**:

```yaml
# application.yml - Redis 보안 강화
spring:
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:#{null}}
      timeout: 2000ms
      ssl: ${REDIS_SSL:false}
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1ms
```

```java
// RedisConfig.java - 보안 설정 추가
@Configuration
public class RedisConfig {

    @Value("${spring.data.redis.password:#{null}}")
    private String password;

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(host);
        config.setPort(port);
        if (password != null && !password.isEmpty()) {
            config.setPassword(password);
        }

        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
            .commandTimeout(Duration.ofSeconds(2))
            .shutdownTimeout(Duration.ZERO)
            .build();

        return new LettuceConnectionFactory(config, clientConfig);
    }
}
```

---

## 🔧 시스템 설정 개선사항

### 🟡 4. DDL 설정 위험성 ⚠️ **HIGH**

**📁 영향 파일**: `application.yml`

**🔍 문제점**:

- `ddl-auto: create` 설정으로 운영 데이터 손실 위험
- 환경별 DDL 전략 미분리
- 데이터베이스 스키마 버전 관리 부재

**✅ 수정 계획**:

```yaml
# application.yml - 환경별 DDL 전략
spring:
  jpa:
    hibernate:
      ddl-auto: ${DDL_AUTO:validate}
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
```

**📋 환경별 DDL 전략**:
| 환경 | DDL 설정 | 용도 | 위험도 |
|------|----------|------|--------|
| **local** | `create-drop` | 로컬 개발 | 낮음 |
| **dev** | `update` | 개발 서버 | 중간 |
| **staging** | `validate` | 스테이징 | 낮음 |
| **prod** | `validate` | 운영 서버 | 없음 |

### 🟡 5. 캐시 설정 최적화 ⚠️ **MEDIUM**

**📁 영향 파일**: `RedisConfig.java`, `CustomCacheErrorHandler.java`

**🔍 문제점**:

- `CustomCacheErrorHandler` 정의되었으나 미등록
- 캐시 TTL 설정 하드코딩
- 캐시 키 네이밍 전략 부재

**✅ 수정 계획**:

```java
// RedisConfig.java - 캐시 매니저 개선
@Bean
public CacheManager cacheManager(
    @Qualifier("cacheConnectionFactory") RedisConnectionFactory connectionFactory,
    CustomCacheErrorHandler errorHandler) {

    RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofMinutes(30))
        .serializeKeysWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new StringRedisSerializer()))
        .serializeValuesWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new GenericJackson2JsonRedisSerializer()))
        .disableCachingNullValues();

    Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
    cacheConfigurations.put("users", defaultConfig.entryTtl(Duration.ofHours(1)));
    cacheConfigurations.put("stores", defaultConfig.entryTtl(Duration.ofMinutes(30)));
    cacheConfigurations.put("policies", defaultConfig.entryTtl(Duration.ofHours(6)));

    return RedisCacheManager.builder(connectionFactory)
        .cacheDefaults(defaultConfig)
        .withInitialCacheConfigurations(cacheConfigurations)
        .transactionAware()
        .build();
}

@Bean
public CacheErrorHandler cacheErrorHandler() {
    return new CustomCacheErrorHandler();
}
```

---

## 🔐 인증/보안 시스템 개선

### 🔴 6. JWT 인증 필터 미완성 ⚠️ **CRITICAL**

**📁 영향 파일**: `JwtAuthenticationFilter.java`

**🔍 문제점**:

- 토큰 검증 후 SecurityContext 설정 로직 주석 처리
- 실제 인증 프로세스가 동작하지 않음
- 토큰 갱신 로직 부재

**✅ 수정 계획**:

```java
// JwtAuthenticationFilter.java - 완전한 인증 로직
@Override
protected void doFilterInternal(HttpServletRequest request, 
                               HttpServletResponse response, 
                               FilterChain filterChain) throws ServletException, IOException {
    try {
        String token = extractToken(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String userId = jwtTokenProvider.getUserIdFromToken(token);

            if (userId != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                Authentication authentication = jwtTokenProvider.getAuthentication(token);
                SecurityContextHolder.getContext().setAuthentication(authentication);

                // 토큰 갱신 체크
                if (jwtTokenProvider.shouldRefreshToken(token)) {
                    String newToken = jwtTokenProvider.refreshToken(token);
                    response.setHeader("New-Token", newToken);
                }

                log.debug("JWT 인증 완료 - 사용자 ID: {}", userId);
            }
        }
    } catch (JwtException e) {
        log.warn("JWT 토큰 검증 실패: {}", e.getMessage());
        SecurityContextHolder.clearContext();
    }

    filterChain.doFilter(request, response);
}

private String extractToken(HttpServletRequest request) {
    String bearerToken = request.getHeader("Authorization");
    if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
        return bearerToken.substring(7);
    }
    return null;
}
```

### 🟡 7. JWT AuthenticationEntryPoint 개선 ⚠️ **MEDIUM**

**📁 영향 파일**: `JwtAuthenticationEntryPoint.java`, `SecurityConfig.java`

**🔍 문제점**:

- JSON 형태가 아닌 응답
- SecurityConfig에서 미등록
- 에러 응답 표준화 부재

**✅ 수정 계획**:

```java
// JwtAuthenticationEntryPoint.java - 표준화된 에러 응답
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, 
                        HttpServletResponse response, 
                        AuthenticationException authException) throws IOException {

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json;charset=UTF-8");

        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("AUTH_001")
            .message("인증이 필요합니다.")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();

        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}

// SecurityConfig.java - EntryPoint 등록
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http
        .exceptionHandling(exceptions -> exceptions
            .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .accessDeniedHandler(jwtAccessDeniedHandler))
        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
        .build();
}
```

### 🟢 8. Security 설정 정리 ⚠️ **LOW**

**📁 영향 파일**: `SecurityConfig.java`

**🔍 문제점**:

- `passwordEncoder()`와 `bCryptPasswordEncoder()` 중복 정의
- 불필요한 Bean 중복

**✅ 수정 계획**:

```java
// SecurityConfig.java - Bean 정리
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12); // 강도 설정
    }

    // bCryptPasswordEncoder() 메서드 제거

    @Bean
    public AuthenticationManager authenticationManager(
        AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

---

## 🎯 AOP 및 성능 최적화

### 🟡 9. AOP 성능 최적화 ⚠️ **MEDIUM**

**📁 영향 파일**: `ServiceLoggingAspect.java`, `PerformanceMonitoringAspect.java`

**🔍 문제점**:

- 두 AOP가 동시 적용 시 성능 오버헤드
- 실행 시간 측정 기능 중복
- 민감한 정보 로깅 위험

**✅ 수정 계획**:

```java
// UnifiedLoggingAspect.java - 통합 AOP
@Aspect
@Component
@Slf4j
public class UnifiedLoggingAspect {

    private static final Set<String> SENSITIVE_PARAMS = Set.of(
        "password", "token", "secret", "key", "credential"
    );

    @Around("execution(* com.rich.sodam.service..*.*(..))")
    public Object logServiceMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();

        // 성능 측정 시작
        long startTime = System.currentTimeMillis();

        try {
            // 파라미터 로깅 (민감한 정보 마스킹)
            Object[] args = joinPoint.getArgs();
            String maskedArgs = maskSensitiveData(args);

            if (log.isDebugEnabled()) {
                log.debug("메서드 시작: {}.{} - 파라미터: {}", 
                    className, methodName, maskedArgs);
            }

            Object result = joinPoint.proceed();

            long executionTime = System.currentTimeMillis() - startTime;

            // 성능 임계값 체크 (500ms)
            if (executionTime > 500) {
                log.warn("성능 경고: {}.{} - 실행시간: {}ms", 
                    className, methodName, executionTime);
            } else if (log.isDebugEnabled()) {
                log.debug("메서드 완료: {}.{} - 실행시간: {}ms", 
                    className, methodName, executionTime);
            }

            return result;

        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;
            log.error("메서드 예외: {}.{} - 실행시간: {}ms - 오류: {}", 
                className, methodName, executionTime, e.getMessage());
            throw e;
        }
    }

    private String maskSensitiveData(Object[] args) {
        // 민감한 정보 마스킹 로직
        return Arrays.stream(args)
            .map(this::maskIfSensitive)
            .map(String::valueOf)
            .collect(Collectors.joining(", "));
    }

    private Object maskIfSensitive(Object arg) {
        if (arg == null) return "null";

        String argString = arg.toString().toLowerCase();
        for (String sensitive : SENSITIVE_PARAMS) {
            if (argString.contains(sensitive)) {
                return "***MASKED***";
            }
        }
        return arg;
    }
}
```

### 🟡 10. 트랜잭션 최적화 ⚠️ **MEDIUM**

**📁 영향 파일**: `TransactionAspect.java`

**🔍 문제점**:

- 읽기 전용 트랜잭션 속성 미사용
- 모든 메서드에 동일한 트랜잭션 속성 적용

**✅ 수정 계획**:

```java
// TransactionConfig.java - 세밀한 트랜잭션 제어
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

    @Bean
    public TransactionInterceptor transactionAdvice(PlatformTransactionManager transactionManager) {
        NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource();

        // 읽기 전용 트랜잭션
        RuleBasedTransactionAttribute readOnlyAttribute = new RuleBasedTransactionAttribute();
        readOnlyAttribute.setReadOnly(true);
        readOnlyAttribute.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS);
        readOnlyAttribute.setTimeout(30);

        source.addTransactionalMethod("get*", readOnlyAttribute);
        source.addTransactionalMethod("find*", readOnlyAttribute);
        source.addTransactionalMethod("search*", readOnlyAttribute);
        source.addTransactionalMethod("count*", readOnlyAttribute);
        source.addTransactionalMethod("exists*", readOnlyAttribute);

        // 쓰기 트랜잭션
        RuleBasedTransactionAttribute writeAttribute = new RuleBasedTransactionAttribute();
        writeAttribute.setRollbackRules(List.of(
            new RollbackRuleAttribute(Exception.class),
            new NoRollbackRuleAttribute(IllegalArgumentException.class)
        ));
        writeAttribute.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        writeAttribute.setTimeout(60);

        source.addTransactionalMethod("save*", writeAttribute);
        source.addTransactionalMethod("update*", writeAttribute);
        source.addTransactionalMethod("delete*", writeAttribute);
        source.addTransactionalMethod("create*", writeAttribute);
        source.addTransactionalMethod("process*", writeAttribute);

        return new TransactionInterceptor(transactionManager, source);
    }
}
```

---

## 💾 캐시 시스템 개선

### 🟡 11. 캐시 메트릭 시스템 개선 ⚠️ **MEDIUM**

**📁 영향 파일**: `CacheMetricsService.java`

**🔍 문제점**:

- 메모리 기반 카운터로 재시작 시 초기화
- Redis KEYS 명령어 사용으로 성능 위험
- 멀티 인스턴스 환경에서 통계 분산

**✅ 수정 계획**:

```java
// CacheMetricsService.java - Redis 기반 메트릭
@Service
@Slf4j
public class CacheMetricsService {

    private final RedisTemplate<String, String> redisTemplate;
    private final MeterRegistry meterRegistry;

    public CacheMetricsService(RedisTemplate<String, String> redisTemplate,
                              MeterRegistry meterRegistry) {
        this.redisTemplate = redisTemplate;
        this.meterRegistry = meterRegistry;
    }

    public void recordCacheHit(String cacheName) {
        String key = "cache:metrics:" + cacheName + ":hits";
        redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, Duration.ofDays(7));

        // Micrometer 메트릭 기록
        Counter.builder("cache.hits")
            .tag("cache", cacheName)
            .register(meterRegistry)
            .increment();
    }

    public void recordCacheMiss(String cacheName) {
        String key = "cache:metrics:" + cacheName + ":misses";
        redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, Duration.ofDays(7));

        Counter.builder("cache.misses")
            .tag("cache", cacheName)
            .register(meterRegistry)
            .increment();
    }

    public CacheStatistics getCacheStatistics(String cacheName) {
        String hitsKey = "cache:metrics:" + cacheName + ":hits";
        String missesKey = "cache:metrics:" + cacheName + ":misses";

        Long hits = Optional.ofNullable(redisTemplate.opsForValue().get(hitsKey))
            .map(Long::valueOf).orElse(0L);
        Long misses = Optional.ofNullable(redisTemplate.opsForValue().get(missesKey))
            .map(Long::valueOf).orElse(0L);

        return CacheStatistics.builder()
            .cacheName(cacheName)
            .hits(hits)
            .misses(misses)
            .hitRatio(calculateHitRatio(hits, misses))
            .totalRequests(hits + misses)
            .build();
    }

    // SCAN 명령어로 성능 개선
    public Set<String> getCacheKeys(String cacheName) {
        Set<String> keys = new HashSet<>();
        String pattern = "sodam:" + cacheName + "*";

        ScanOptions options = ScanOptions.scanOptions()
            .match(pattern)
            .count(100)
            .build();

        try (Cursor<String> cursor = redisTemplate.scan(options)) {
            cursor.forEachRemaining(keys::add);
        } catch (Exception e) {
            log.error("캐시 키 조회 실패 - 캐시명: {}, 오류: {}", cacheName, e.getMessage());
        }

        return keys;
    }

    private double calculateHitRatio(Long hits, Long misses) {
        long total = hits + misses;
        return total == 0 ? 0.0 : (double) hits / total * 100;
    }
}
```

### 🟢 12. 캐시 워밍업 전략 개선 ⚠️ **LOW**

**📁 영향 파일**: `CacheWarmupService.java`

**🔍 문제점**:

- 사용자 캐시에 Optional.of(user) 직접 저장
- 하드코딩된 정책 (100개 제한)

**✅ 수정 계획**:

```java
// CacheWarmupService.java - 개선된 워밍업 전략
@Service
@Slf4j
public class CacheWarmupService {

    private final UserService userService;
    private final StoreService storeService;
    private final PolicyInfoService policyInfoService;

    @Value("${cache.warmup.user-limit:200}")
    private int userWarmupLimit;

    @Value("${cache.warmup.store-limit:100}")
    private int storeWarmupLimit;

    @EventListener(ApplicationReadyEvent.class)
    public void warmupCaches() {
        log.info("캐시 워밍업 시작");

        CompletableFuture.allOf(
            CompletableFuture.runAsync(this::warmupUserCache),
            CompletableFuture.runAsync(this::warmupStoreCache),
            CompletableFuture.runAsync(this::warmupPolicyCache)
        ).thenRun(() -> log.info("캐시 워밍업 완료"));
    }

    private void warmupUserCache() {
        try {
            List<User> recentUsers = userService.findRecentActiveUsers(userWarmupLimit);

            for (User user : recentUsers) {
                try {
                    // 서비스 메서드를 통한 캐시 워밍업 (캐시 어노테이션 활용)
                    userService.findByEmail(user.getEmail());
                    userService.findById(user.getId());
                } catch (Exception e) {
                    log.warn("사용자 캐시 워밍업 실패 - 사용자 ID: {}, 오류: {}", 
                        user.getId(), e.getMessage());
                }
            }

            log.info("사용자 캐시 워밍업 완료 - 대상: {}명", recentUsers.size());

        } catch (Exception e) {
            log.error("사용자 캐시 워밍업 전체 실패", e);
        }
    }

    private void warmupStoreCache() {
        try {
            List<Store> activeStores = storeService.findActiveStores(storeWarmupLimit);

            for (Store store : activeStores) {
                try {
                    storeService.findById(store.getId());
                    storeService.findStoreEmployees(store.getId());
                } catch (Exception e) {
                    log.warn("매장 캐시 워밍업 실패 - 매장 ID: {}", store.getId());
                }
            }

            log.info("매장 캐시 워밍업 완료 - 대상: {}개", activeStores.size());

        } catch (Exception e) {
            log.error("매장 캐시 워밍업 전체 실패", e);
        }
    }

    private void warmupPolicyCache() {
        try {
            // 최신 정책 정보 캐시 워밍업
            policyInfoService.findRecentPolicies(50);
            log.info("정책 정보 캐시 워밍업 완료");
        } catch (Exception e) {
            log.error("정책 정보 캐시 워밍업 실패", e);
        }
    }
}
```

---

## 🌐 API 및 Controller 개선

### 🔴 13. LoginController 보안 강화 ⚠️ **CRITICAL**

**📁 영향 파일**: `LoginController.java`

**🔍 문제점**:

- `redirectUrl`, `clientId` 변수 미정의
- 토큰을 응답 본문과 쿠키 양쪽에 노출
- 토큰 만료 시간 하드코딩
- RuntimeException 직접 사용

**✅ 수정 계획**:

```java
// LoginController.java - 보안 강화
@RestController
@RequestMapping("/api/auth")
@Slf4j
@Validated
public class LoginController {

    @Value("${kakao.redirect-url}")
    private String redirectUrl;

    @Value("${kakao.client-id}")
    private String clientId;

    @Value("${jwt.cookie.secure:true}")
    private boolean secureCookie;

    @Value("${jwt.cookie.same-site:Strict}")
    private String sameSite;

    private final AuthService authService;
    private final JwtTokenProvider jwtTokenProvider;

    @PostMapping("/kakao/callback")
    public ResponseEntity<AuthResponse> kakaoCallback(
        @Valid @RequestBody KakaoCallbackRequest request,
        HttpServletResponse response) {

        try {
            // 카카오 인증 처리
            KakaoUserInfo userInfo = authService.processKakaoAuth(request.getCode());
            User user = authService.findOrCreateUser(userInfo);

            // JWT 토큰 생성
            TokenPair tokenPair = jwtTokenProvider.generateTokenPair(user);

            // Access Token은 HttpOnly 쿠키로만 전달
            addTokenCookie(response, "accessToken", tokenPair.getAccessToken(), 
                jwtTokenProvider.getAccessTokenExpiration());

            // Refresh Token은 별도 HttpOnly 쿠키
            addTokenCookie(response, "refreshToken", tokenPair.getRefreshToken(),
                jwtTokenProvider.getRefreshTokenExpiration());

            // 응답에는 토큰 제외하고 사용자 정보만 포함
            AuthResponse authResponse = AuthResponse.builder()
                .userId(user.getId())
                .email(user.getEmail())
                .userGrade(user.getUserGrade().getValue())
                .loginTime(LocalDateTime.now())
                .build();

            log.info("사용자 로그인 성공 - 사용자 ID: {}, 이메일: {}", 
                user.getId(), user.getEmail());

            return ResponseEntity.ok(authResponse);

        } catch (AuthenticationException e) {
            log.warn("인증 실패: {}", e.getMessage());
            throw new CustomAuthenticationException("인증에 실패했습니다.", e);
        } catch (Exception e) {
            log.error("로그인 처리 중 오류 발생", e);
            throw new InternalServerException("로그인 처리 중 오류가 발생했습니다.");
        }
    }

    @PostMapping("/refresh")
    public ResponseEntity<Void> refreshToken(
        HttpServletRequest request, 
        HttpServletResponse response) {

        String refreshToken = extractTokenFromCookie(request, "refreshToken");

        if (refreshToken == null || !jwtTokenProvider.validateToken(refreshToken)) {
            throw new InvalidTokenException("유효하지 않은 리프레시 토큰입니다.");
        }

        try {
            String newAccessToken = jwtTokenProvider.refreshAccessToken(refreshToken);
            addTokenCookie(response, "accessToken", newAccessToken,
                jwtTokenProvider.getAccessTokenExpiration());

            return ResponseEntity.ok().build();

        } catch (Exception e) {
            log.error("토큰 갱신 실패", e);
            throw new TokenRefreshException("토큰 갱신에 실패했습니다.");
        }
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(HttpServletRequest request, HttpServletResponse response) {
        // 쿠키 삭제
        clearTokenCookie(response, "accessToken");
        clearTokenCookie(response, "refreshToken");

        // Redis에서 토큰 무효화
        String accessToken = extractTokenFromCookie(request, "accessToken");
        if (accessToken != null) {
            authService.invalidateToken(accessToken);
        }

        return ResponseEntity.ok().build();
    }

    private void addTokenCookie(HttpServletResponse response, String name, 
                               String value, long maxAge) {
        Cookie cookie = new Cookie(name, value);
        cookie.setHttpOnly(true);
        cookie.setSecure(secureCookie);
        cookie.setPath("/");
        cookie.setMaxAge((int) (maxAge / 1000));
        cookie.setAttribute("SameSite", sameSite);
        response.addCookie(cookie);
    }

    private void clearTokenCookie(HttpServletResponse response, String name) {
        Cookie cookie = new Cookie(name, "");
        cookie.setHttpOnly(true);
        cookie.setSecure(secureCookie);
        cookie.setPath("/");
        cookie.setMaxAge(0);
        response.addCookie(cookie);
    }

    private String extractTokenFromCookie(HttpServletRequest request, String cookieName) {
        if (request.getCookies() != null) {
            return Arrays.stream(request.getCookies())
                .filter(cookie -> cookieName.equals(cookie.getName()))
                .map(Cookie::getValue)
                .findFirst()
                .orElse(null);
        }
        return null;
    }
}
```

---

## 🔄 서비스 레이어 개선

### 🟡 14. RedisService 타입 통일 ⚠️ **MEDIUM**

**📁 영향 파일**: `RedisService.java`

**🔍 문제점**:

- `verifyToken()` 메서드의 userId 파라미터가 String인데 다른 메서드는 Long
- 메서드 시그니처 불일치로 인한 타입 안전성 문제

**✅ 수정 계획**:

```java
// RedisService.java - 타입 통일 및 개선
@Service
@Slf4j
public class RedisService {

    private final RedisTemplate<String, Object> jwtRedisTemplate;
    private final RedisTemplate<String, String> redisTemplate;

    private static final String USER_TOKENS_PREFIX = "USER_TOKENS:";
    private static final String TOKEN_BLACKLIST_PREFIX = "TOKEN_BLACKLIST:";

    public void storeToken(Long userId, String token, Duration expiration) {
        try {
            String key = USER_TOKENS_PREFIX + userId;
            String tokenHash = hashToken(token);

            jwtRedisTemplate.opsForHash().put(key, tokenHash, token);
            jwtRedisTemplate.expire(key, expiration);

            log.debug("토큰 저장 완료 - 사용자 ID: {}", userId);
        } catch (Exception e) {
            log.error("토큰 저장 실패 - 사용자 ID: {}, 오류: {}", userId, e.getMessage());
            throw new TokenStorageException("토큰 저장에 실패했습니다.", e);
        }
    }

    public boolean verifyToken(Long userId, String token) {
        try {
            String key = USER_TOKENS_PREFIX + userId;
            String tokenHash = hashToken(token);
            Object storedToken = jwtRedisTemplate.opsForHash().get(key, tokenHash);

            boolean isValid = storedToken != null;
            log.debug("토큰 검증 결과 - 사용자 ID: {}, 유효성: {}", userId, isValid);

            return isValid;
        } catch (Exception e) {
            log.error("토큰 검증 실패 - 사용자 ID: {}, 오류: {}", userId, e.getMessage());
            return false;
        }
    }

    public void removeToken(Long userId, String token) {
        try {
            String key = USER_TOKENS_PREFIX + userId;
            String tokenHash = hashToken(token);

            jwtRedisTemplate.opsForHash().delete(key, tokenHash);
            log.debug("토큰 제거 완료 - 사용자 ID: {}", userId);
        } catch (Exception e) {
            log.error("토큰 제거 실패 - 사용자 ID: {}, 오류: {}", userId, e.getMessage());
        }
    }

    public void blacklistToken(String token, Duration expiration) {
        try {
            String key = TOKEN_BLACKLIST_PREFIX + hashToken(token);
            redisTemplate.opsForValue().set(key, "blacklisted", expiration);

            log.debug("토큰 블랙리스트 등록 완료");
        } catch (Exception e) {
            log.error("토큰 블랙리스트 등록 실패: {}", e.getMessage());
        }
    }

    public boolean isTokenBlacklisted(String token) {
        try {
            String key = TOKEN_BLACKLIST_PREFIX + hashToken(token);
            return Boolean.TRUE.equals(redisTemplate.hasKey(key));
        } catch (Exception e) {
            log.error("토큰 블랙리스트 확인 실패: {}", e.getMessage());
            return false;
        }
    }

    private String hashToken(String token) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(token.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            log.error("토큰 해시 생성 실패", e);
            throw new RuntimeException("토큰 해시 생성에 실패했습니다.", e);
        }
    }
}
```

---

## 📱 React Native 관련 분석 (신규 추가)

### 🟡 15. React Native 설정 최적화 ⚠️ **MEDIUM**

**🔍 분석 결과**:
프로젝트 기획서에 따르면 React Native 0.80.0 기반 크로스 플랫폼 개발이 계획되어 있으나, 현재 백엔드 중심의 분석만 진행됨.

**📋 React Native 관련 권장사항**:

#### 15.1 API 응답 형식 표준화

```typescript
// 백엔드 API 응답 표준화 (React Native 호환)
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  timestamp: string;
  requestId: string;
}

// 페이지네이션 응답
interface PagedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    size: number;
    totalElements: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}
```

#### 15.2 React Native Web 지원 고려사항

```java
// CORS 설정 (React Native Web 지원)
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOriginPatterns("*")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

#### 15.3 모바일 최적화 API 설계

```java
// 모바일 친화적 API 응답 크기 최적화
@RestController
@RequestMapping("/api/mobile")
public class MobileOptimizedController {

    @GetMapping("/attendance/summary")
    public ResponseEntity<MobileAttendanceSummary> getAttendanceSummary(
        @RequestParam Long userId,
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {

        // 모바일에 필요한 최소한의 데이터만 반환
        MobileAttendanceSummary summary = attendanceService.getMobileSummary(userId, date);
        return ResponseEntity.ok(summary);
    }
}
```

---

## 🗄️ 데이터베이스 최적화 분석 (신규 추가)

### 🟡 16. 데이터베이스 성능 최적화 ⚠️ **MEDIUM**

**🔍 분석 결과**:
현재 MyBatis 기반 데이터 접근 계층이 구현되어 있으나, 성능 최적화 관점에서 개선이 필요함.

**📊 데이터베이스 최적화 권장사항**:

#### 16.1 인덱스 전략

```sql
-- 출근 기록 조회 최적화
CREATE INDEX idx_attendance_user_date ON attendance(user_id, attendance_date DESC);
CREATE INDEX idx_attendance_store_date ON attendance(store_id, attendance_date DESC);

-- 급여 계산 최적화
CREATE INDEX idx_wage_employee_store ON wages(employee_id, store_id);
CREATE INDEX idx_wage_effective_date ON wages(effective_date DESC);

-- 사용자 검색 최적화
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_user_status_created ON users(status, created_at DESC);

-- 매장 관리 최적화
CREATE INDEX idx_store_owner ON stores(owner_id);
CREATE INDEX idx_store_location ON stores(latitude, longitude);
```

#### 16.2 쿼리 최적화

```java
// MyBatis 쿼리 최적화 예시
@Mapper
public interface AttendanceMapper {

    // 페이지네이션 최적화
    @Select("""
        SELECT a.*, u.name as user_name, s.name as store_name
        FROM attendance a
        JOIN users u ON a.user_id = u.id
        JOIN stores s ON a.store_id = s.id
        WHERE a.store_id = #{storeId}
        AND a.attendance_date BETWEEN #{startDate} AND #{endDate}
        ORDER BY a.attendance_date DESC, a.check_in_time DESC
        LIMIT #{offset}, #{limit}
        """)
    List<AttendanceDetailDto> findAttendanceWithDetails(
        @Param("storeId") Long storeId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate,
        @Param("offset") int offset,
        @Param("limit") int limit
    );

    // 집계 쿼리 최적화
    @Select("""
        SELECT 
            DATE(attendance_date) as work_date,
            COUNT(*) as total_employees,
            SUM(TIMESTAMPDIFF(MINUTE, check_in_time, check_out_time)) as total_minutes
        FROM attendance
        WHERE store_id = #{storeId}
        AND attendance_date BETWEEN #{startDate} AND #{endDate}
        AND check_out_time IS NOT NULL
        GROUP BY DATE(attendance_date)
        ORDER BY work_date DESC
        """)
    List<DailyWorkSummary> getDailyWorkSummary(
        @Param("storeId") Long storeId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );
}
```

#### 16.3 연결 풀 최적화

```yaml
# application.yml - HikariCP 최적화
spring:
  datasource:
    hikari:
      maximum-pool-size: ${DB_POOL_SIZE:20}
      minimum-idle: ${DB_MIN_IDLE:5}
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
      pool-name: SodamHikariPool
      connection-test-query: SELECT 1
      validation-timeout: 5000
```

---

## 📊 성능 모니터링 시스템 (신규 추가)

### 🟡 17. 애플리케이션 모니터링 구축 ⚠️ **MEDIUM**

**🔍 현재 상태**:
기본적인 로깅은 구현되어 있으나, 체계적인 성능 모니터링 시스템이 부재함.

**✅ 모니터링 시스템 구축 계획**:

#### 17.1 Micrometer 기반 메트릭 수집

```java
// MetricsConfig.java - 커스텀 메트릭 설정
@Configuration
public class MetricsConfig {

    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }

    @Bean
    public CountedAspect countedAspect(MeterRegistry registry) {
        return new CountedAspect(registry);
    }

    @Bean
    @ConditionalOnMissingBean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
            .commonTags("application", "sodam")
            .commonTags("environment", "${spring.profiles.active:unknown}");
    }
}

// 비즈니스 메트릭 수집
@Service
public class BusinessMetricsService {

    private final Counter checkInCounter;
    private final Counter checkOutCounter;
    private final Timer salaryCalculationTimer;
    private final Gauge activeUsersGauge;

    public BusinessMetricsService(MeterRegistry meterRegistry) {
        this.checkInCounter = Counter.builder("business.checkin.total")
            .description("총 출근 횟수")
            .register(meterRegistry);

        this.checkOutCounter = Counter.builder("business.checkout.total")
            .description("총 퇴근 횟수")
            .register(meterRegistry);

        this.salaryCalculationTimer = Timer.builder("business.salary.calculation.duration")
            .description("급여 계산 소요 시간")
            .register(meterRegistry);

        this.activeUsersGauge = Gauge.builder("business.users.active")
            .description("활성 사용자 수")
            .register(meterRegistry, this, BusinessMetricsService::getActiveUserCount);
    }

    public void recordCheckIn(String storeType) {
        checkInCounter.increment(Tags.of("store.type", storeType));
    }

    public void recordSalaryCalculation(Duration duration) {
        salaryCalculationTimer.record(duration);
    }

    private double getActiveUserCount() {
        // 활성 사용자 수 계산 로직
        return 0.0; // 실제 구현 필요
    }
}
```

#### 17.2 헬스 체크 엔드포인트 확장

```java
// CustomHealthIndicator.java - 커스텀 헬스 체크
@Component
public class DatabaseHealthIndicator implements HealthIndicator {

    private final DataSource dataSource;

    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up()
                    .withDetail("database", "MySQL")
                    .withDetail("validationQuery", "SELECT 1")
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withDetail("database", "MySQL")
                .withDetail("error", e.getMessage())
                .build();
        }

        return Health.down()
            .withDetail("database", "MySQL")
            .withDetail("error", "Connection validation failed")
            .build();
    }
}

@Component
public class RedisHealthIndicator implements HealthIndicator {

    private final RedisTemplate<String, String> redisTemplate;

    @Override
    public Health health() {
        try {
            String pong = redisTemplate.getConnectionFactory()
                .getConnection()
                .ping();

            if ("PONG".equals(pong)) {
                return Health.up()
                    .withDetail("redis", "Available")
                    .withDetail("response", pong)
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("redis", "Unavailable")
                .withDetail("error", e.getMessage())
                .build();
        }

        return Health.down()
            .withDetail("redis", "Unavailable")
            .build();
    }
}
```

#### 17.3 로그 구조화 및 중앙집중화

```yaml
# logback-spring.xml 설정
logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{requestId}] %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{requestId}] %logger{36} - %msg%n"
  level:
    com.rich.sodam: ${LOG_LEVEL:INFO}
    org.springframework.security: WARN
    org.springframework.web: ${WEB_LOG_LEVEL:INFO}
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${SQL_PARAM_LOG_LEVEL:WARN}
  file:
    name: ${LOG_FILE:logs/sodam.log}
    max-size: 100MB
    max-history: 30
```

---

## 🚀 배포 및 운영 전략 (신규 추가)

### 🟡 18. 배포 환경 최적화 ⚠️ **MEDIUM**

**🔍 현재 상태**:
AWS 기반 배포가 계획되어 있으나, 구체적인 배포 전략 및 환경 설정이 부족함.

**📋 배포 전략 권장사항**:

#### 18.1 환경별 설정 관리

```yaml
# application-prod.yml - 운영환경 설정
spring:
  profiles:
    active: prod
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 300000
      max-lifetime: 1800000
  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      password: ${REDIS_PASSWORD}
      ssl: true
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5

jwt:
  secret: ${JWT_SECRET}
  expiration: 3600000
  refresh-expiration: 604800000

logging:
  level:
    com.rich.sodam: INFO
    org.springframework.security: WARN
  file:
    name: /var/log/sodam/application.log
    max-size: 200MB
    max-history: 60

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    export:
      prometheus:
        enabled: true
```

#### 18.2 Docker 컨테이너화

```dockerfile
# Dockerfile - 멀티 스테이지 빌드
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY gradlew .
COPY gradle gradle
COPY build.gradle .
COPY settings.gradle .
COPY src src

RUN chmod +x ./gradlew
RUN ./gradlew bootJar

FROM openjdk:17-jre-slim

RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY --from=builder /app/build/libs/*.jar app.jar

# 비root 사용자 생성
RUN groupadd -r sodam && useradd -r -g sodam sodam
RUN chown -R sodam:sodam /app
USER sodam

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

#### 18.3 CI/CD 파이프라인

```yaml
# .github/workflows/deploy.yml
name: Deploy to AWS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Run tests
      run: ./gradlew test

    - name: Generate test report
      run: ./gradlew jacocoTestReport

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-2

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: sodam
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Deploy to ECS
      run: |
        aws ecs update-service --cluster sodam-cluster --service sodam-service --force-new-deployment
```

---

## 🧪 테스트 전략 강화

### 🟡 19. 테스트 커버리지 확대 ⚠️ **MEDIUM**

**🔍 현재 상태**:
Mockito 사용 금지 가이드라인에 따라 실제 컴포넌트 기반 테스트 전략 필요.

**✅ 테스트 전략 개선 계획**:

#### 19.1 TestContainers 기반 통합 테스트

```java
// IntegrationTestBase.java - 통합 테스트 기반 클래스
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
@Transactional
public abstract class IntegrationTestBase {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("sodam_test")
            .withUsername("test")
            .withPassword("test")
            .withReuse(true);

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
            .withExposedPorts(6379)
            .withReuse(true);

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);

        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", redis::getFirstMappedPort);
    }

    @Autowired
    protected TestRestTemplate restTemplate;

    @Autowired
    protected TestEntityManager entityManager;

    protected void cleanDatabase() {
        entityManager.getEntityManager()
            .createNativeQuery("SET FOREIGN_KEY_CHECKS = 0")
            .executeUpdate();

        // 테스트 데이터 정리
        entityManager.getEntityManager()
            .createNativeQuery("TRUNCATE TABLE attendance")
            .executeUpdate();
        entityManager.getEntityManager()
            .createNativeQuery("TRUNCATE TABLE users")
            .executeUpdate();

        entityManager.getEntityManager()
            .createNativeQuery("SET FOREIGN_KEY_CHECKS = 1")
            .executeUpdate();
    }
}

// AttendanceServiceIntegrationTest.java - 실제 통합 테스트
class AttendanceServiceIntegrationTest extends IntegrationTestBase {

    @Autowired
    private AttendanceService attendanceService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private StoreRepository storeRepository;

    @Test
    @DisplayName("출근 처리 통합 테스트 - 성공")
    void checkIn_Integration_Success() {
        // Given
        User user = createTestUser();
        Store store = createTestStore();
        CheckInRequest request = CheckInRequest.builder()
            .userId(user.getId())
            .storeId(store.getId())
            .latitude(37.5665)
            .longitude(126.9780)
            .build();

        // When
        AttendanceResponse response = attendanceService.checkIn(request);

        // Then
        assertThat(response).isNotNull();
        assertThat(response.getUserId()).isEqualTo(user.getId());
        assertThat(response.getStoreId()).isEqualTo(store.getId());
        assertThat(response.getCheckInTime()).isNotNull();

        // 데이터베이스 확인
        Optional<Attendance> savedAttendance = attendanceService
            .findTodayAttendance(user.getId(), store.getId());
        assertThat(savedAttendance).isPresent();
        assertThat(savedAttendance.get().getCheckInTime()).isNotNull();
    }

    private User createTestUser() {
        User user = User.builder()
            .email("test@example.com")
            .name("테스트 사용자")
            .userGrade(UserGrade.EMPLOYEE)
            .build();
        return userRepository.save(user);
    }

    private Store createTestStore() {
        Store store = Store.builder()
            .name("테스트 매장")
            .latitude(37.5665)
            .longitude(126.9780)
            .address("서울시 중구 명동")
            .build();
        return storeRepository.save(store);
    }
}
```

#### 19.2 성능 테스트

```java
// PerformanceTest.java - 성능 테스트
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PerformanceTest extends IntegrationTestBase {

    @Test
    @DisplayName("동시 출근 처리 성능 테스트")
    void concurrentCheckIn_PerformanceTest() throws InterruptedException {
        // Given
        int threadCount = 100;
        int requestsPerThread = 10;
        ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);

        List<Long> responseTimes = Collections.synchronizedList(new ArrayList<>());
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);

        // When
        for (int i = 0; i < threadCount; i++) {
            executorService.submit(() -> {
                try {
                    for (int j = 0; j < requestsPerThread; j++) {
                        long startTime = System.currentTimeMillis();

                        try {
                            // 출근 처리 요청
                            CheckInRequest request = createCheckInRequest();
                            attendanceService.checkIn(request);

                            long responseTime = System.currentTimeMillis() - startTime;
                            responseTimes.add(responseTime);
                            successCount.incrementAndGet();

                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                        }
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(30, TimeUnit.SECONDS);
        executorService.shutdown();

        // Then
        double averageResponseTime = responseTimes.stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);

        long maxResponseTime = responseTimes.stream()
            .mapToLong(Long::longValue)
            .max()
            .orElse(0L);

        System.out.println("=== 성능 테스트 결과 ===");
        System.out.println("총 요청 수: " + (threadCount * requestsPerThread));
        System.out.println("성공 수: " + successCount.get());
        System.out.println("실패 수: " + errorCount.get());
        System.out.println("평균 응답 시간: " + averageResponseTime + "ms");
        System.out.println("최대 응답 시간: " + maxResponseTime + "ms");

        // 성능 기준 검증
        assertThat(averageResponseTime).isLessThan(500.0); // 평균 500ms 이하
        assertThat(maxResponseTime).isLessThan(2000L); // 최대 2초 이하
        assertThat(errorCount.get()).isLessThan(threadCount * requestsPerThread * 0.01); // 에러율 1% 이하
    }
}
```

---

## 📊 종합 우선순위 및 로드맵

### 🎯 우선순위별 수정 계획

#### 🔴 CRITICAL (즉시 수정 필요)

| 순위 | 항목                    | 예상 소요 시간 | 담당자     |
|----|-----------------------|----------|---------|
| 1  | JWT Secret Key 보안 문제  | 2시간      | 백엔드 개발자 |
| 2  | 데이터베이스 비밀번호 노출        | 1시간      | DevOps  |
| 3  | JWT 인증 필터 미완성         | 4시간      | 백엔드 개발자 |
| 4  | LoginController 보안 강화 | 6시간      | 백엔드 개발자 |

#### 🟡 HIGH (단기 수정 권장 - 1주일 내)

| 순위 | 항목            | 예상 소요 시간 | 담당자     |
|----|---------------|----------|---------|
| 5  | DDL 설정 위험성    | 2시간      | 백엔드 개발자 |
| 6  | Redis 보안 설정   | 3시간      | DevOps  |
| 7  | 데이터베이스 성능 최적화 | 8시간      | DBA/백엔드 |
| 8  | API 응답 표준화    | 4시간      | 백엔드 개발자 |

#### 🟡 MEDIUM (중기 개선 - 2주일 내)

| 순위 | 항목                  | 예상 소요 시간 | 담당자        |
|----|---------------------|----------|------------|
| 9  | 캐시 설정 최적화           | 6시간      | 백엔드 개발자    |
| 10 | AOP 성능 최적화          | 8시간      | 백엔드 개발자    |
| 11 | 모니터링 시스템 구축         | 16시간     | DevOps/백엔드 |
| 12 | 테스트 커버리지 확대         | 20시간     | 전체 팀       |
| 13 | React Native 연동 최적화 | 12시간     | 프론트엔드      |

#### 🟢 LOW (장기 개선 - 1개월 내)

| 순위 | 항목           | 예상 소요 시간 | 담당자    |
|----|--------------|----------|--------|
| 14 | 배포 환경 최적화    | 24시간     | DevOps |
| 15 | 성능 테스트 자동화   | 16시간     | QA/백엔드 |
| 16 | 코드 정리 및 리팩토링 | 40시간     | 전체 팀   |

### 📅 4주 로드맵

#### 1주차: 보안 이슈 해결

- [x] JWT Secret Key 환경변수화
- [x] 데이터베이스 비밀번호 보안
- [x] JWT 인증 필터 완성
- [x] LoginController 보안 강화

#### 2주차: 성능 및 안정성 개선

- [ ] DDL 설정 환경별 분리
- [ ] Redis 보안 설정
- [ ] 데이터베이스 인덱스 최적화
- [ ] API 응답 표준화

#### 3주차: 모니터링 및 테스트

- [ ] 캐시 시스템 최적화
- [ ] AOP 성능 개선
- [ ] 모니터링 시스템 구축
- [ ] 통합 테스트 확대

#### 4주차: 배포 및 운영 준비

- [ ] React Native 연동 최적화
- [ ] CI/CD 파이프라인 구축
- [ ] 성능 테스트 자동화
- [ ] 문서화 완성

---

## 🎯 권장사항 및 베스트 프랙티스

### 🔒 보안 강화 방안

1. **환경변수 관리**: 모든 민감한 정보를 환경변수로 관리
2. **토큰 보안**: JWT 토큰 노출 최소화 및 HttpOnly 쿠키 활용
3. **API 보안**: Rate Limiting, CORS 설정, 입력 검증 강화
4. **데이터 암호화**: 민감한 데이터의 저장 시 암호화 적용

### ⚡ 성능 최적화 전략

1. **캐시 전략**: Redis 기반 다층 캐시 구조 구축
2. **데이터베이스**: 인덱스 최적화 및 쿼리 튜닝
3. **AOP 최적화**: 중복 제거 및 조건부 로깅
4. **연결 풀**: HikariCP 설정 최적화

### 🧪 테스트 전략

1. **실제 컴포넌트 테스트**: TestContainers 활용
2. **통합 테스트**: 전체 플로우 검증
3. **성능 테스트**: 동시성 및 부하 테스트
4. **자동화**: CI/CD 파이프라인 통합

### 📊 모니터링 및 운영

1. **메트릭 수집**: Micrometer + Prometheus
2. **로그 관리**: 구조화된 로깅 및 중앙집중화
3. **헬스 체크**: 커스텀 헬스 인디케이터
4. **알림 시스템**: 임계값 기반 알림 설정

### 🚀 배포 및 DevOps

1. **컨테이너화**: Docker 멀티 스테이지 빌드
2. **환경 분리**: 개발/스테이징/운영 환경 구분
3. **자동 배포**: GitHub Actions + AWS ECS
4. **롤백 전략**: 무중단 배포 및 빠른 롤백

---

## 📝 결론 및 다음 단계

### 🎯 핵심 요약

소담(SODAM) 프로젝트는 **React Native 기반 크로스 플랫폼 아르바이트 관리 애플리케이션**으로서 견고한 Spring Boot 백엔드 아키텍처를 기반으로 구축되었습니다.

**주요 강점**:

- ✅ 체계적인 레이어드 아키텍처
- ✅ JWT 기반 인증 시스템 기반 구조
- ✅ Redis 캐시 시스템 도입
- ✅ AOP 기반 횡단 관심사 처리
- ✅ MyBatis 기반 데이터 접근 계층

**즉시 해결 필요한 보안 이슈**:

- 🚨 JWT Secret Key 하드코딩 (CRITICAL)
- 🚨 데이터베이스 비밀번호 노출 (CRITICAL)
- 🚨 JWT 인증 필터 미완성 (CRITICAL)
- 🚨 LoginController 보안 취약점 (CRITICAL)

### 📈 개선 효과 예상

#### 보안 강화 후:

- **보안 위험도**: 90% → 10% 감소
- **컴플라이언스**: OWASP 기준 충족
- **운영 안정성**: 토큰 위조 방지, 데이터 유출 차단

#### 성능 최적화 후:

- **응답 시간**: 평균 30% 개선 예상
- **동시 처리량**: 50% 증가 예상
- **캐시 히트율**: 80% 이상 달성 목표

#### 테스트 커버리지 확대 후:

- **코드 커버리지**: 현재 미측정 → 80% 이상 목표
- **버그 발견율**: 운영 전 90% 이상 사전 발견
- **배포 안정성**: 자동화된 테스트로 배포 위험 최소화

### 🚀 다음 단계 액션 플랜

#### 즉시 실행 (24시간 내)

1. **환경변수 설정**: JWT Secret, DB Password 환경변수화
2. **JWT 필터 수정**: 인증 로직 완성
3. **긴급 보안 패치**: 운영 환경 보안 설정 적용

#### 1주일 내 완료

1. **데이터베이스 최적화**: 인덱스 생성 및 쿼리 튜닝
2. **API 표준화**: React Native 호환 응답 형식 적용
3. **Redis 보안 설정**: 비밀번호 및 SSL 적용

#### 2주일 내 완료

1. **모니터링 시스템**: Micrometer + Prometheus 구축
2. **테스트 자동화**: TestContainers 기반 통합 테스트
3. **성능 테스트**: 부하 테스트 및 병목 지점 해결

#### 1개월 내 완료

1. **CI/CD 파이프라인**: 자동 빌드/테스트/배포 구축
2. **React Native 최적화**: 모바일 앱 연동 완성
3. **운영 문서화**: 장애 대응 매뉴얼 및 운영 가이드

### 🎯 성공 지표 (KPI)

| 지표            | 현재            | 목표          | 측정 방법      |
|---------------|---------------|-------------|------------|
| **보안 취약점**    | 4개 (Critical) | 0개          | 정적 분석 도구   |
| **API 응답 시간** | 미측정           | 평균 200ms 이하 | APM 도구     |
| **캐시 히트율**    | 미측정           | 80% 이상      | Redis 메트릭  |
| **테스트 커버리지**  | 미측정           | 80% 이상      | JaCoCo 리포트 |
| **배포 성공률**    | 수동 배포         | 95% 이상      | CI/CD 메트릭  |
| **시스템 가용성**   | 미측정           | 99.9% 이상    | 모니터링 도구    |

### 💡 장기 비전

소담 프로젝트는 단순한 근태 관리를 넘어서 **종합적인 아르바이트 생태계 플랫폼**으로 발전할 수 있는 견고한 기술적 기반을 갖추고 있습니다.

**기술적 확장 가능성**:

- 🔮 AI 기반 급여 예측 및 최적화
- 🔮 블록체인 기반 급여 지급 시스템
- 🔮 IoT 연동 자동 출퇴근 시스템
- 🔮 빅데이터 분석 기반 인사이트 제공

**비즈니스 확장 가능성**:

- 📈 세무사/노무사 플랫폼 연계 확대
- 📈 B2B SaaS 모델로 확장
- 📈 글로벌 시장 진출 (다국어/다통화 지원)
- 📈 핀테크 서비스 연계 (급여 선지급 등)

본 분석 보고서에서 제시한 개선 계획을 체계적으로 실행하면, 소담 프로젝트는 **안전하고 확장 가능하며 성능이 우수한 플랫폼**으로 성장할 수 있을 것입니다.

---

## 📚 참고 문서 및 리소스

### 🔗 관련 문서

- [프로젝트 기획서](../project-management/project_planning_Document.md)
- [개발 가이드라인](../guidelines/development_guidelines.md)
- [체크리스트](../project-management/Check_List.md)

### 📖 기술 참조

- [Spring Boot Security 가이드](https://spring.io/guides/gs/securing-web/)
- [Redis 성능 최적화](https://redis.io/docs/manual/optimization/)
- [React Native 성능 가이드](https://reactnative.dev/docs/performance)
- [AWS 배포 베스트 프랙티스](https://aws.amazon.com/architecture/well-architected/)

### 🛠️ 도구 및 라이브러리

- [TestContainers](https://www.testcontainers.org/)
- [Micrometer](https://micrometer.io/)
- [JaCoCo](https://www.jacoco.org/)
- [Checkstyle](https://checkstyle.sourceforge.io/)

---

**📅 문서 변경 이력**

| 날짜         | 버전  | 변경 내용            | 작성자 |
|------------|-----|------------------|-----|
| 2024-12-27 | 2.0 | 서식 정리 및 내용 대폭 보강 | 개발팀 |
| 2024-12-26 | 1.0 | 초기 분석 보고서 작성     | 개발팀 |
