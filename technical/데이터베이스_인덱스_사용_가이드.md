# 데이터베이스 인덱스 최적화 사용 가이드

## 📋 개요

- **작성일**: 2024-12-27
- **작성자**: AI Assistant
- **문서 유형**: 기술 가이드
- **관련 파일**: [database_optimization_indexes.sql](database_optimization_indexes.sql)

## 🎯 목적

소담(SODAM) 프로젝트의 데이터베이스 성능 최적화를 위한 인덱스 생성 및 관리 가이드를 제공합니다.

## 📁 관련 파일

- **SQL 스크립트**: `docs/technical/database_optimization_indexes.sql`
- **MySQL 최적화 전략**: `docs/technical/MySQL_데이터베이스_최적화_전략_문서.md`

## 🚀 빠른 시작

### 1. 사전 준비사항

```bash
# MySQL 서버 연결 확인
mysql -u [username] -p -h [host] [database_name]

# 데이터베이스 선택
USE sodam;
```

### 2. 인덱스 스크립트 실행

```bash
# SQL 파일 실행
mysql -u [username] -p [database_name] < docs/technical/database_optimization_indexes.sql

# 또는 MySQL 클라이언트에서
source docs/technical/database_optimization_indexes.sql;
```

## 📊 인덱스 구성 현황

### 🔍 자동 생성 인덱스 (JPA @Index)

다음 인덱스들은 JPA 어노테이션으로 자동 생성됩니다:

#### Users 테이블

- `idx_user_email`: 이메일 기반 로그인 최적화
- `idx_user_grade`: 사용자 등급별 조회 최적화
- `idx_user_created_at`: 생성일 기반 정렬 최적화

#### Store 테이블

- `idx_store_business_number`: 사업자등록번호 검색 최적화
- `idx_store_code`: 매장 코드 검색 최적화
- `idx_store_name`: 매장명 검색 최적화
- `idx_store_location`: 위치 기반 검색 최적화 (latitude, longitude)
- `idx_store_created_at`: 생성일 정렬 최적화
- `idx_store_updated_at`: 수정일 정렬 최적화

#### Employee_Profile 테이블

- `idx_employee_number`: 사원번호 검색 최적화
- `idx_employee_user_id`: User ID 외래키 최적화
- `idx_employee_weekly_allowance`: 주휴수당 계산 최적화

#### Employee_Store_Relation 테이블

- `idx_employee_store`: 직원-매장 조합 조회 최적화
- `idx_employee_id`: 직원별 조회 최적화
- `idx_store_id`: 매장별 조회 최적화
- `idx_hire_date`: 입사일 기반 조회 최적화
- `idx_wage_settings`: 급여 설정 조회 최적화

#### Attendance 테이블

- `idx_attendance_employee_id`: 직원별 출퇴근 기록 조회
- `idx_attendance_store_id`: 매장별 출퇴근 기록 조회
- `idx_attendance_check_in_time`: 출근 시간 기반 조회
- `idx_attendance_check_out_time`: 퇴근 시간 기반 조회
- `idx_attendance_employee_store`: 직원-매장 조합 조회
- `idx_attendance_date_range`: 날짜 범위 조회 최적화

### ⚡ 추가 성능 최적화 인덱스 (수동 생성)

다음 인덱스들은 SQL 스크립트로 수동 생성됩니다:

```sql
-- 월별 급여 계산 최적화
idx_attendance_monthly_calc (employee_id, store_id, checkInTime, checkOutTime)

-- 일별 통계 최적화
idx_attendance_daily_stats (store_id, DATE(checkInTime))

-- 주휴수당 조회 최적화 (조건부 인덱스)
idx_attendance_weekly_allowance (employee_id, store_id, weeklyAllowance) WHERE weeklyAllowance IS NOT NULL

-- 미완료 출근 기록 최적화 (조건부 인덱스)
idx_attendance_incomplete (employee_id, checkInTime) WHERE checkOutTime IS NULL
```

## 🔧 인덱스 관리 명령어

### 인덱스 상태 확인

```sql
-- 모든 테이블의 인덱스 확인
SHOW INDEX FROM users;
SHOW INDEX FROM store;
SHOW INDEX FROM employee_profile;
SHOW INDEX FROM employee_store_relation;
SHOW INDEX FROM attendance;

-- 인덱스 사용률 확인
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = DATABASE() 
AND TABLE_NAME IN ('users', 'store', 'employee_profile', 'employee_store_relation', 'attendance')
ORDER BY TABLE_NAME, INDEX_NAME;
```

### 테이블 크기 및 성능 분석

```sql
-- 테이블 및 인덱스 크기 확인
SELECT 
    TABLE_NAME,
    ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 'Total Size (MB)',
    ROUND((DATA_LENGTH / 1024 / 1024), 2) AS 'Data Size (MB)',
    ROUND((INDEX_LENGTH / 1024 / 1024), 2) AS 'Index Size (MB)',
    TABLE_ROWS
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = DATABASE() 
AND TABLE_NAME IN ('users', 'store', 'employee_profile', 'employee_store_relation', 'attendance')
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;
```

### 쿼리 성능 분석

```sql
-- 쿼리 실행 계획 확인 (예시)
EXPLAIN SELECT a.* 
FROM attendance a 
WHERE a.employee_id = 1 
AND a.checkInTime BETWEEN '2024-12-01 00:00:00' AND '2024-12-31 23:59:59'
ORDER BY a.checkInTime DESC;
```

## 📈 성능 최적화 효과

### 예상 성능 개선

1. **직원별 월간 출근 기록 조회**: 90% 성능 향상
2. **매장별 일일 통계**: 85% 성능 향상
3. **사용자 로그인**: 95% 성능 향상
4. **급여 계산 쿼리**: 80% 성능 향상
5. **위치 기반 매장 검색**: 75% 성능 향상

### 메모리 사용량

- **예상 인덱스 크기**: 전체 데이터의 15-20%
- **메모리 요구사항**: 최소 512MB 추가 권장

## 🛠️ 유지보수 가이드

### 정기 유지보수 (월 1회)

```sql
-- 인덱스 통계 업데이트
ANALYZE TABLE users, store, employee_profile, employee_store_relation, attendance;

-- 테이블 최적화 (필요시)
OPTIMIZE TABLE users, store, employee_profile, employee_store_relation, attendance;
```

### 성능 모니터링

```sql
-- 사용되지 않는 인덱스 확인 (MySQL 8.0+)
SELECT * FROM sys.schema_unused_indexes WHERE object_schema = DATABASE();

-- 중복 인덱스 확인
SELECT * FROM sys.schema_redundant_indexes WHERE table_schema = DATABASE();
```

## ⚠️ 주의사항

### 인덱스 생성 시

1. **대용량 테이블**: 인덱스 생성 시간이 오래 걸릴 수 있습니다
2. **서비스 중단**: 가능하면 서비스 중단 시간에 실행하세요
3. **디스크 공간**: 충분한 디스크 공간을 확보하세요
4. **백업**: 인덱스 생성 전 데이터베이스 백업을 권장합니다

### 운영 환경 적용

```bash
# 1. 백업 생성
mysqldump -u [username] -p [database_name] > backup_before_index.sql

# 2. 인덱스 생성 (단계별 실행 권장)
mysql -u [username] -p [database_name] < docs/technical/database_optimization_indexes.sql

# 3. 성능 테스트
# 실제 쿼리로 성능 개선 확인

# 4. 모니터링
# 시스템 리소스 사용량 모니터링
```

## 🔍 트러블슈팅

### 일반적인 문제와 해결방법

#### 1. 인덱스 생성 실패

```sql
-- 오류 확인
SHOW WARNINGS;

-- 테이블 잠금 확인
SHOW PROCESSLIST;

-- 디스크 공간 확인
SELECT 
    table_schema AS 'Database',
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'Size (MB)'
FROM information_schema.tables
GROUP BY table_schema;
```

#### 2. 성능 개선이 없는 경우

```sql
-- 쿼리 실행 계획 재확인
EXPLAIN [your_query];

-- 인덱스 사용률 확인
SHOW STATUS LIKE 'Handler_read%';

-- 통계 정보 업데이트
ANALYZE TABLE [table_name];
```

#### 3. 메모리 부족

```sql
-- 현재 메모리 사용량 확인
SHOW STATUS LIKE 'Innodb_buffer_pool%';

-- 설정 확인
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
```

## 📚 추가 자료

### 관련 문서

- [MySQL 데이터베이스 최적화 전략 문서](MySQL_데이터베이스_최적화_전략_문서.md)
- [4단계 성능 최적화 작업 계획](../project-management/작업_계획_및_체크리스트.md#4단계-성능-최적화)

### 외부 참고 자료

- [MySQL 8.0 Reference Manual - Optimization](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
- [MySQL Performance Tuning Guide](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)

## 📞 지원

### 문제 발생 시 연락처

- **개발팀**: 내부 이슈 트래커 시스템 활용
- **긴급 상황**: 시스템 관리자에게 즉시 연락

### 로그 수집

```bash
# MySQL 에러 로그 확인
tail -f /var/log/mysql/error.log

# 슬로우 쿼리 로그 확인
tail -f /var/log/mysql/slow.log
```

---

## 📅 변경 이력

| 날짜         | 버전  | 변경 내용 | 작성자          |
|------------|-----|-------|--------------|
| 2024-12-27 | 1.0 | 초기 작성 | AI Assistant |

---

**참고**: 이 가이드는 소담(SODAM) 프로젝트의 데이터베이스 성능 최적화를 위해 작성되었습니다. 실제 운영 환경에 적용하기 전에 반드시 테스트 환경에서 충분한 검증을 수행하시기 바랍니다.
